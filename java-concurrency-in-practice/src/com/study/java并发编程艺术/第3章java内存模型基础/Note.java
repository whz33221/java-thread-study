package com.study.java并发编程艺术.第3章java内存模型基础;

public class Note {
    /**
     * 知识点的角色：重排序，JMM，
     * 组件层：提供同步工具类
     * 语言层面：定义sychorinzed,volatile,final，等具有特殊内存语义的关键字
     * JMM: 向上为程序员提供了一套统一的内存模型进行内存操作
     * JMM：定义了happenedbefore规则
     *      向上：作为程序员判断自己编写的程序能否有序执行的基本依据
     *      向下: 作为1、2重排操作是否合法判断依据
     * JMM：向下通过抽象内存模型，屏蔽2、3的差异
     * 1.不同编译器对代码具有不同重排策略
     * 2.不同的平台处理器硬件具有不同的重排执令执行的策略
     * 3.不同平台处理器的内存模型（优化策略）导致不同重排序现象
     *
     * 一、内存模型的两个关键问题
     *      1.线程之间如何通信
     *      1>通信是指线程之间以何种机制来交换信息
     *      2>机制：
     *          -共享内存
     *              通过操作内存中的公共状态进行隐式通信
     *          -消息通信
     *              线程之间没有公共状态，线程之间必须通过发生消息进行通信
     *
     *      2.线程之间如何同步
     *      1>同步是指程序中用于控制不同线程间操作发生的相对顺序的机制
     *          -共享内存
     *              通过程序员定义互斥代码和方法，达到显式同步的效果
     *          -消息通信
     *              消息的发送必须再消息接收之前，达到隐式同步的效果
     *
     * 二、java的内存模型
     *      1.机制的使用
     *          java内存模型使用了共享内存机制
     *      2.如何实现一致性问题
     *          1>重排序问题
     *              -分类
     *                  1》编译器重排
     *                  2》处理器重排
     *                  3》系统内存重排
     *              -定义
     *                  重排序就是cpu执行效率优化带来的一种程序执行乱序化的表现
     *                  反过来，重排序越少，cpu执行效率越低
     *              -happenedbefore程序顺序执行规则（处理多线程维度）
     *                  通过定义happenedbefore规则，屏蔽底层复杂的重排序规则提供给程序员
     *              在java内存模型层面上阐述操作间可见性的方法，从而使程序员可以通过此规则
     *              设计自己代码，令JVM在编译时知道应该在哪些地方里加入内存屏障，以控制
     *              消除影响可见性的各个层面的重排序问题，保证线程间可见性
     *
     *              -其他重排规则的规则支持
     *                  -数据依赖性（编译器和处理器只在单个线程角度规则检验与处理）
     *                  -as-if-serial（同上）
     *          2>一致性问题
     *              -理论基础概念
     *                 顺序一致性模型：同步设计的核心理论基础
     *                      》多有线程只能看到一个单一的操作(同一时间只有一个线程执行)，
     *                      》每个线程必须按照程序的顺序来执行内存读（顺序必须按程序定义顺序）
     *                      》每个操作都必须原子执行（要执行完一段同步过的复合操作）
     *                      》且立刻对所有线程可见（操作主存）
     *                 数据竞争：线程之间同时对同一个变量进行操作，且顺序不可确定，导致结果
     *                 不可预测
     *                 同步：线程间按正确一致操作顺序进行执行
     *                 广义上的同步：正确的执行synchronized、volatile、final
     *              -JMM对顺序一致性模型的应用
     *                  JMM就是通过程序员提供具有正确的同步代码程序，明析定义临界区范围，
     *                  以顺序一致性模型作为理论支持，happenbefore作为具体重排规则，重排代码
     *                  后，执行临界区代码，实现java的顺序一致性功能要求
     *              -具体实现
     *                  1》提供happenedbefore规则作为程序员判断自己编写的程序能否有序执行的基本依据
     *                  2》以happenedbefore为判断重排的合法性
     *                  全局理解：
     *                      程序员利用具有不同内存语义的代码，以happenedbefore作为
     *                  编写有序代码的依据，编写出一个程序，如果该程序在happenedbefore规则下
     *                  执行结果始终唯一，那么就可以认为该程序正确的同步。
     *                      编译器，处理器在重排序该程序的代码的时候，就会以happenedbefore为
     *                  约束，如果重排后与happenedbefore规则下执行的结果不同，则重排不合法
     *         3>原子性问题
     *              -JMM原子操作实现细节
     *                  利用总线事务（总线锁）
     *
     * 三、什么是happenedbefore
     *      -happenedbefore具有两层角度的定义
     *          1>对于程序员，是JMM对程序员的承诺
     *              只要代码满足happenedbefore规则，JMM就会向程序员保证满足happenedbefore
     *          的代码会安排代码定义的顺序有序执行
     *          2>对于编译器和处理器，是重排序的约束（判断重排是否合法的基准）
     *              只要重排序后的代码，与按照happenedbefore规则执行的代码，执行结果始终一样，
     *          那么编译器和处理器就可以认为此重排序合法
     *              例子：比如如果一个volatile变量始终为单线程访问，根据hb规则需要加入屏障，但是
     *          编译器在分析过后发现他只有单线程会访问，那么那就不会加入屏障，并允许对vo重排
     * 疑问：
     *      1.编译器，处理器为什么要与happenedbefore比较，直接使用happenedbefore不是更简洁？
     *      答：这是为了最大程度的释放cpu性能，越贴合顺序一致性模型（越严的重排约束），
     *      cpu性能越低，如果没必要进行重排约束，就没必要做，这有利于cpu性能的提升
     *
     *
     *
     */
}
