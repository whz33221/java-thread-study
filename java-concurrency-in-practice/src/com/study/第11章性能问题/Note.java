package com.study.第11章性能问题;

public class Note {
    /**
     *
     * 一.性能与可伸缩性
     *      1.什么是高性能
     *          通俗：有效地利用现有处理资源
     *          本质：让CPU在有效作业中保持忙碌
     *      2.性能的指标
     *          1>“多快”指标：服务时间，延迟时间，吞吐率，效率
     *          2>“能做多少”指标：生产量，吞吐量
     *      3.什么是可伸缩性
     *          当增加计算机资源时，程序的吞吐量或者处理能力能相应的增加
     *      4.性能与可伸缩性的关系
     *          二者更多时候是矛盾的，为了可伸缩性，不可避免要损失一点性能，但是在软件开发中，可
     *        伸缩性比性能更重要
     *        （个人认为因为性能不够，伸缩性好的程序可以加资源来达到提高性能的目的，同时可维护
     *        性更高）
     * 二.评估各种性能权衡因素
     *      1.本节核心：
     *          避免不成熟的优化，先让程序正确运行，然后在基于需求或一系列数据，设计优化方案
     *      2.优化是有前提和场景的!
     *          1>前提：要进行优化，就必须现有明确的需求，优化永无止境，我们应该找最适合的方案，而不是
     *        最快的方案，这就是为什么先把程序做出来，在根据实际情况，收集数据，分析数据，明确需求，
     *        最后在进行方案设计
     *          2>场景：高负载下快？低负载下快？大数据?小数据？环境要求？
     *      3.优化是有利有弊的！
     *          1>越聪明的代码，越快的算法，越复杂，越晦涩难懂，越难维护
     *          2>优化有时候是以破坏对象设计原则为代价
     *          3>有时候优化会带来更高的错误风险
     *        综上所述: 如果你无法找出优化方案在其中的代价和风险，就代表你还没有彻底思考和分析清楚，
     *        你还没有做好优化的准备
     *      4.优化需要验证后再进行一次权衡！
     *          1>根据目标需求进行优化后，必须进行测试验证，看是否达到目标
     *          2>根据与目标的差异，我们需要权衡优化所带来的益处是否大于优化方案所付出的代价，考虑
     *        是否最终实装方案
     * 三.Amdahl定律
     *      可优化的比率取决于一个软件的串行运行时间比率
     * 四.线程引入的开销(带来计算量的增加)
     *      1.开销的分析
     *          1>上下文切换
     *          2>内存同步（同步开销）
     *              1)非竞争的同步开销：
     *          首先开销就不大，其次JVM已经对其做了许多优化，比如锁去除，锁粒度粗化（锁合并）
     *              2）竞争的同步开销
     *      2.理解阻塞
     *          1>如何发生：
     *              在锁发生竞争时，对于抢不到锁的线程，JVM会根据历史等待时间，进行自旋等待（等待时间短），或者
     *           线程挂起（等待时间长）
     * 五.减少所竞争（减少计算量的同时，降低串行代码比例）
     *      1.减少锁持有的时间（快点使用锁）
     *          1>缩小锁的范围
     *      2.减少锁的请求频率（少点人用锁）
     *          1>减小锁的粒度---锁分解/锁分段
     *      3.避免热点域
     *          1>是什么？
     *              被大量不同的操作频繁访问的域就是热点域
     *          2>为什么？
     *              热点域看似提高了某部分代码的性能，但同时带来了软件可伸缩性损失
     *          3>怎么做？
     *              少用热点域，如果用，要慎用，对标ConcurentHashMap的实现，合理的减小热点域的被访问范围
     *      4.使用带有协调机制的独占锁
     *          比如并发容器、读写锁、不可改变对象、原子变量
     *      5.少用对象池
     *          通常对象分配操作的开销比同步的开销更低
     *          1.是什么？
     *              为了减少JVM创建和销毁对象的开销，而设计的对象数据结构
     *          2.为什么？
     *              1>Jvm已经对创建对象做了很多优化，开销已经非常小
     *              2>因为对象池也是个热点域，那么就会带来同步竞争的开销同时，牺牲了软件可伸缩性
     *              3>因为1，2，对于轻量级的对象，对象池带来的开销更大（创建与销毁开销 < 锁竞争）
     *          3.怎么做？
     *              少用
     * 六.减少上下文切换的开销
     *      1.减少占用竞争资源的任务时间
     *      2.减少参与竞争的线程 或者 设计一个专门访问竞争资源的线程（比如某个IO输出流）
     *
     *
     */
}
