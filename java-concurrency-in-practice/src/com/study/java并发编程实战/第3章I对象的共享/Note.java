package com.study.java并发编程实战.第3章I对象的共享;

public class Note {
    /**
     * 一、可见性
     * 1.为什么说对于一个变量，应该用唯一一个锁来做线程安全的设计？
     *      1）可以保证后面开发人员不会在选择锁上花时间--》提高维护性
     *      2）可以百分百保证线程间的同步代码块相互之间的可见性---P30
     *      考虑一种情况，如果12用A锁，34用B锁，那么实际上并不能保证1的操作能被3看见
     * 2.JVM在服务器中，会以server模式运行，在开发环境会以client模式运行
     *      1）两者区别：
     *      相比server模式，client模式会少一些代码重排和内存优化
     *      2）导致问题：
     *      因为在server端，多了代码重排和内存优化，会出现不可见问题，最终
     *      导致在开发环境能运行，而在server端不能得到正确的结果的情况发生
     * 3.volatile只能赋予变量可见性，并不能赋予变量变访问时的操作原子性
     * 4.原子性的理解
     *      根据需求，对复合操作进行定义，达到需求同时，满足线程安全，这种操作就具有
     *      原子性
     *
     * 二、发布与逸出
     * 5.发布的定义：使对象能够在当前作用域之外的代码中使用，称为发布
     * 6.逸出的定义：当某个不应该被发布的对象被发布时，称为逸出
     * 7.封装与逸出的交叉：
     *      封装使我们对程序的正确分析称为可能，让程序员通过封装设计使用对象的约束规则，
     *      来发布一个不被误用的对象
     * 8.当且仅当在构造方法返回之后，对象的状态才处于可以被预测和一致的状态。
     *
     * 三、线程封闭
     * 9.线程封闭技术：通过代码设计，在不进行同步的前提下，令某个对象同一时间只运行于单个线程，实现
     * 线程安全，这种技术叫做线程封闭技术
     * 10.封闭技术总览
     *      1）ad-hoc线程封闭
     *      2）栈封闭（参考spring-mvc设计）
     *      3) threadLocal
     *
     * 四、不可变性
     * 1.无需考虑因不可变，使程序需要不断new对象，而造成性能下降，内存分配反而带来性能优势，因为
     * 降低了对加锁和保护下副本的需求，以及降低对基于“代”的垃圾回收机制影响？，这些操作性能消耗
     * 比分配内存高多了
     * 2.尽量地使用private和final，是良好的编程习惯
     * 3.使用volatile发布不可变对象，在某些情况下，能提供若形式的原子性?
     *
     * 五、安全发布
     * 1.为什么存在安全发布的问题？
     *      因为当一个对象，作为某个对象的域，进行发布时（即new 出来），存在多个线程访问的可能
     *      1）那么就要考虑线程安全问题：可见性、竞态条件
     *      2）正确发布的问题：在对象构造的过程中，有线程访问的可能，而在这个过程中对象状态是不可预测的
     * 2.在方法中new对象，属于安全发布吗？
     *      大多数情况属于，因为该情况属于栈封闭，有且只有触发new的线程，属于单线程，线程安全。
     *      例外情况：被new的对象在构造方法中存在this逸出，那么就有可能有线程安全的问题
     * 3.安全发布的定义：
     *      保证对象在构造方法中，不被其他线程访问，不发生this逸出，在构造方法完成后，对象的状态改变，
     *      在各个线程间可见，各线程对对象状态修改始终能得到正确结果
     *      总结：
     *          1.正确发布：在构造阶段，不发生逸出，其他线程不可访问
     *          2.线程安全：在构造阶段之后，保证线程安全
     * 4.各种共享对象的类型的发布需求
     *      1）不可变对象---》随便发布
     *      2）事实不可变对象（如Date）---》需要保证正确发布
     *      3）可变对象---》保证安全发布且发布后线程安全
     * 5.设计安全发布的常用手段
     *      1）在static域中，发布对象---》保证正确发布
     *      2）使用volatile或者final定义---》保证可见性，满足非引用类型的对象的安全发布
     *      3）使用锁保护域---》保证线程安全
     *      4）单线程访问---》满足安全发布
     *      5）不可变对象---》满足安全发布
     *      6）使用线程安全的容器---》满足非引用类型的对象的安全发布
     * 6.实现安全发布的技术
     *      1）线程封闭（使用了单线程访问设计）
     *      2）只读共享（使用了不可变对象）
     *      3）线程安全共享（使用了锁机制）
     *      4）保护对象（使用了线程安全容器）
     */
}
