package com.study.java并发编程实战.第14章构建自定义的同步工具;

public class Note {
    /**
     * 一、条件队列的组成
     *      定义：条件队列指的是一组在等待某个条件变成真的线程，队列中的元素是线程
     *      1.条件谓词
     *      某种情况某个状态变量必须满足的一个或多个条件，必须写入文档
     *      2.状态变量
     *      3.保护状态变量的锁
     * 二、当使用条件等待时
     *      1.通常都有一个条件谓词在生效（条件成立/未成立）
     *      2.调用wait的前后都必须队条件谓词进行测试，防止信号丢失和过早唤醒。
     *      3.在一个循环中调用wait
     *      4.确保所有的条件谓词的状态变量，都能有相对应的锁进行保护
     *      5.等调用wait（）notify（）或notifyAll()等方法必须持有相关锁
     *      6.在检查条件谓词之后以及执行完相应操作之前，不要释放锁
     * 三、信号丢失
     *      1.调用wait前没有检测条件谓语，就会发生信号丢失：A队列改变了状态，发了通知后，B在此之后
     *      获取锁，没有检测，直接等待，就会发生信号丢失，发生死锁
     * 四、过早唤醒
     *      1.调用wait后没有检测条件谓语，就会发生，B线程wait了之后，被不明线程活性，因为没有对
     *      条件谓语进行检测执行，直接往下执行，此时条件谓语与线程B行为不匹配，造成过早唤醒
     * 五、通知
     *      1.notify()
     *          1>使用场景：
     *          只有在同一个等待队列中，所有的线程的类型都相同，线程允许单进单出，才能用单一的notify
     *          2>优点：
     *          性能更高
     *      2.notifyAll()
     *          1>使用场景
     *          适用于所有场景
     *          2>优点：
     *          安全性更高
     *          3>缺点
     *          当线程多，锁竞争激烈的时候，会发生大量上下文切换，锁的竞争，以及锁的挂起与恢复，这些
     *          操作带来大量的性能浪费
     * 六、子类的继承问题
     *      1.一旦有子类，第三方就有可能错误的进行扩展
     *          应对：
     *          1)不允许继承
     *          2）在文档中把公开的条件队列和锁，条件谓词，同步策略都写清楚入文档
     * 七、封装条件队列
     *      1.定义：把条件队列所有涉及的元素封装在一个类中进行设计维护
     *      2.优点：防止第三方采用违背设计的方式使用条件队列
     *      3.缺点：封装好的条件类不再支持任何客户端形式的加锁，因为涉及的锁被封装在类中
     *      4.相对的：利用内置锁作为封装后条件队列的锁，虽然破坏了封装性，但是客户端可以以此进行
     * 八、Condition
     *      1.作用：使一个锁可以拥有多个等待队列
     *      2.优点：更容易满足单次通知的需求
     *      3.使用方法：从显式锁new出来，然后使用api-await（） signal（）signalAll
     * 九、Semaphore
     *      1.可以简单理解，ReentrantLock就是一个信号量为1的Semaphore
     * 十、AQS-AbstractQueuedSynchronizer
     *      1.AQS是一个用于构建锁和同步器的框架
     *      ReentrantLock\Semaphore\CountDownLatch\FutureTask都是用了该框架进行实现
     */
}
