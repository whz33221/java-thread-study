package com.study.第6章I任务执行;

public class Note {
    /**
     *一、认识任务和执行策略之间的隐性关系
     *      1.依赖性任务：某个任务执行依赖于某个任务执行完成
     *      ===》线程池执行策略：提供足够大的线程池，防止发生安全性或活跃性问题
     *      2.使用线程封闭机制的任务：某个任务必须在单线程环境下运行
     *      ===》线程池执行策略：单线程池
     *      3.对响应时间敏感的任务：需要及时响应
     *      ===》线程池策略：1.提供足够大的线程。2.设计上让该线程池拥有同类型的任务
     *      4.使用ThreadLocal
     *      ===》线程池策略：
     *          1）当该ThreadLocal变量的生命周期范围受限于任务生命周期，可用
     *          2）不要利用ThreadLocal在线程池的线程间传递变量
     *          PS:因为线程池的线程，有可能因为异常销毁，然后重新新建一条新线程，有的情况，会因空闲回收
     *
     *二、如何应对任务和执行策略之间的隐性关系
     *      1.依赖性任务--》导致线程饥饿死锁
     *          1）要考虑需要多大的线程池才防止死锁
     *          2）要以文档形式，标注明白使用了什么策略，需要多少个线程来防止死锁
     *          3）考虑其他资源上的隐式限制，必须JDBC的连接池
     *      2.运行时间过长的任务--》影响同一个线程池中任务的吞吐量
     *          1）扩大线程数、加快任务执行效率
     *          2）为该类型任务独立线程池
     *          3）缓解措施：限定任务等待资源的时间（使用有界队列，提交任务限时超过时间时
     *          ，直接判定任务失败）
     *三、设置线程池的大小
     *      1.最优线程数受很多因素影响
     *          1）计算环境
     *          2）资源预算
     *          3）任务预算
     *          4）依赖的资源-JDBC连接池
     *          5）内存，文件句柄，套接字举句柄等等
     *      2.计算密集型任务，一般来说Ncpu+1能实现最优利用率
     *四、管理线程池队列任务
     *      1.了解各默认线程池的分类
     *      newFixedThreadPool: 无界队列
     *      newSingleThreadExecutor: 无界队列
     *      newCachedThreadPool：SynchronousQueue,同步队列
     *      2.队列的选择
     *          1）对于避免资源耗尽的需求：考虑使用BlockingQueue阻塞队列
     *          2）对于非常大或无界线程池：考虑使用SynchronousQueue（直接移交，线程数
     *          达到max，将拒绝任务）避免任务排队
     *          3）控制任务执行顺序: 考虑使用LinkedBlockingQueue、ArrayBlockingQueue（先进先出）
     *          4）按优先级：考虑使用PriorityBlockingQueue
     *
     *
     *
     *
     *
     *
     */
}
