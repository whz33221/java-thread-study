package com.study.第8章I线程池的使用;

public class Note {
    /**
     *一、认识任务和执行策略之间的隐性关系
     *      1.依赖性任务：某个任务执行依赖于某个任务执行完成
     *      ===》线程池执行策略：提供足够大的线程池，防止发生安全性或活跃性问题
     *      2.使用线程封闭机制的任务：某个任务必须在单线程环境下运行
     *      ===》线程池执行策略：单线程池
     *      3.对响应时间敏感的任务：需要及时响应
     *      ===》线程池策略：1.提供足够大的线程。2.设计上让该线程池拥有同类型的任务
     *      4.使用ThreadLocal
     *      ===》线程池策略：
     *          1）当该ThreadLocal变量的生命周期范围受限于任务生命周期，可用
     *          2）不要利用ThreadLocal在线程池的线程间传递变量
     *          PS:因为线程池的线程，有可能因为异常销毁，然后重新新建一条新线程，有的情况，会因空闲回收
     *
     *二、如何应对任务和执行策略之间的隐性关系
     *      1.依赖性任务--》导致线程饥饿死锁
     *          1）要考虑需要多大的线程池才防止死锁
     *          2）要以文档形式，标注明白使用了什么策略，需要多少个线程来防止死锁
     *          3）考虑其他资源上的隐式限制，必须JDBC的连接池
     *      2.运行时间过长的任务--》影响同一个线程池中任务的吞吐量
     *          1）扩大线程数、加快任务执行效率
     *          2）为该类型任务独立线程池
     *          3）缓解措施：限定任务等待资源的时间（使用有界队列，提交任务限时超过时间时
     *          ，直接判定任务失败）
     *三、设置线程池的大小
     *      1.最优线程数受很多因素影响
     *          1）计算环境
     *          2）资源预算
     *          3）任务预算
     *          4）依赖的资源-JDBC连接池
     *          5）内存，文件句柄，套接字举句柄等等
     *      2.计算密集型任务，一般来说Ncpu+1能实现最优利用率
     *四、管理线程池队列任务
     *      1.了解各默认线程池的分类
     *      newFixedThreadPool: 无界队列
     *      newSingleThreadExecutor: 无界队列
     *      newCachedThreadPool：SynchronousQueue,同步队列
     *      2.队列的选择
     *          1）对于避免资源耗尽的需求：考虑使用BlockingQueue阻塞队列
     *          2）当线程池线程数非常多：考虑使用SynchronousQueue（直接移交，线程数
     *          达到max，将拒绝任务）避免任务排队
     *          3）控制任务执行顺序: 考虑使用LinkedBlockingQueue、ArrayBlockingQueue（先进先出）
     *          4）按优先级：考虑使用PriorityBlockingQueue
     *          5）当任务存在依赖性：考虑使用无界线程池
     *      3.饱和策略：当队列满的时候执行的策略
     *          1）AbortPolicy（中止）：饱和时，抛出rejectedExcecutionException
     *          2）Discard（抛弃）：饱和时，会悄悄抛弃该任务
     *          3）DiscardOldest（抛弃最旧的）：实质上是抛弃下一个执行的任务，所以在优先队列中
     *          语义就会变成抛弃优先级最高的任务
     *          ———>所以一般该策略与优先级队列不共用
     *          4）CallerRun（调用者执行）：饱和时，任务会由调用execute的线程自行执行。
     *          5）特殊策略实现：信号量控制：通过信号量来控制任务量，当信号量被获取完，就无法提交
     *          任务
     *
     *五、线程池的使用
     *      1.线程工厂ThreadFactory作用
     *          1）定义池中线程名称同时并入池的名称
     *          2）对于某些需要利用安全策略来控制对特殊代码访问时，可以用privilegedThreadFactory
     *          工厂来定制自己的线程工厂，创建出的线程会继承工厂权限，如果不用，创建出的线程将继承提交任务
     *          线程的权限
     *      2.为工厂定制线程类
     *          1）定义池中线程名称
     *          2）定义线程池的异常处理
     *          3）存储以下统计信息
     *      3.访问线程池设置器：
     *          ExecutorService可以强转为ThreadPoolExecutor进行访问
     *      4.扩展ThreadPoolExecutor
     *          1）beforeExecute：任务执行前调用，如果发生异常，后续任务和afterExecute将不再执行
     *          2）afterExecute：任务执行后调用，如果任务执行过程中异常，还是会执行
     *          3）terminated：在线程池完成关闭操作时调用（所有任务完成且所有线程回收完）
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     */
}
