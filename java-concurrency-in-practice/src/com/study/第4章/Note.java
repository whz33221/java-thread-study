package com.study.第4章;

public class Note {
    /**对象的组合
     *
     *
     * 一、设计线程安全类
     * & 找出构造对象状态的所有变量（若变量为引用类型，还包括引用对象中的域）
     * & 约束状态变量的不变性条件
     * & 建立对象状态的并发访问管理策略（规定了如何维护线程安全性）
     *
     * 1.收集同步需求（需要进行的分析元素）
     *      1）不变性条件: 在程序执行过程或部分过程中，可始终被假定成立的条件
     *      2）后验证条件: 针对方法（method），它规定了方法顺利执行完毕之后必须为真的条件
     * 2.依赖状态操作
     *      1）先验条件： 针对方法（method），它规定了在调用该方法之前必须为真的条件
     * 3.状态所有权
     *      1）哪些类可以持有操作状态的控制权，要清楚定义其范围
     *
     * 二、实例封闭(设计线程安全类的技术1)
     *      把对象封装到某个类，该类拥有定义该变量如何被操作的控制权，使对象在整个程序中的
     * 线程安全分析成为可能。
     * 1.封闭锁：相对于共有访问的锁，有效保证锁在整个程序中正确的使用
     *
     * 三、线程安全性的委托(设计线程安全类的技术2)
     * 1.根据实际情况，考虑把线程安全性委托给线程安全的类（例如AtomicLong）
     *
     * 四、在现有的线程安全类中添加功能
     * 1.通过子类扩展（线程安全性脆弱）因为一旦服务端代码的同步策略被修改，所有扩展子类有可能无效
     * 2.通过辅助类扩展（线程安全性脆弱）因为此方法是以模拟服务端代码的同步策略进行扩展，会有同上问题
     * 3.通过组合，把非扩展功能委托给目标类对象，拓展类通过内置锁，增加一层额外的加锁（代码健壮）
     * 不会出现1，2的问题，因为拓展类不关心你如何同步，他自己有一套同步策略，且拓展方法会在这个策略
     * 基础上设计，当服务端代码同步策略改变，也不会影响拓展类的同步策略，虽然性能上会有些消耗，但是以此
     * 换来代码的健壮性和线程安全性是完全值得的
     *
     */
}
