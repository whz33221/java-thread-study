package com.study.第10章I活跃性问题;

public class Note {
    /**
     * 活跃性问题：死锁、饥饿、活锁
     * 一.死锁：线程间发生锁冲突，导致阻塞
     * 1.分类
     *      1）顺序死锁
     *        某个方法定义了错误的获取锁顺序，导致线程没有以统一的方法进行获取锁，发生死锁
     *      2）动态的顺序死锁
     *        方法没有明确定义获取锁顺序，根据传参数，会有不同的锁顺序，其中包括错误的获取锁顺序，导致死锁发生
     *      3）协作之间对象之间发生死锁
     *          对象协作时，原理与前者相同，当因为获取锁隐藏于被调用的方法内，非常难以分辨---应对：开放调用
     *      4）资源死锁
     *         基于资源的死锁：
     *            1>等待双方在用资源死锁，比如两个数据库，线程1获取了A库所有资源，线程2获取了B库所有资源，线程1此时需要获取B库资源才能往下执行，
     *            线程2同理，导致双方永远无法获取到资源，发生死锁
                  2>线程饥饿死锁：比如单线程池，提交了AB任务，A任务执行到中间，需要等B完成，此时B永远在等待队列，导致死锁
     * 2.应对措施
     *      1）开放调用
     *          1>尽量缩小锁范围
     *          2>不要使用同步方法，改用同步代码块，显式的进行加锁
     *      2）定时锁设计
     * 3.如何排查死锁
     *      1）通过线程转储信息来分析死锁
     *
     *
     * 二.饥饿：当线程由于无法访问它所需要的资源而不能继续执行时，就会发生饥饿
     * 1.发生原因
     *      1）java线程的优先级使用不当
     *      2）某个线程持有了锁后，执行了个无限循环的任务，导致其他线程无法获取到锁
     * 2.应对
     *      1）使用默认线程优先级
     *      ps：一旦修改了优先级，则程序就对平台具有依赖性，不同的平台，对优先级的处理也不同
     *      2）每个同步任务必须是可以运行结束的
     *
     *
     * 三.活锁：线程间不停的互相礼让（不断重复相同的操作），导致线程没有阻塞，但任务进度始终无法往下执行
     * 1.发生原因
     *      两个线程在协作时，在一些判断对方状态的操作时，表现出相同状态，且修改自身状态步调
     * 相同，导致不断判断，不断修改
     * 2.应对
     *      加入随机元素，比如随机的改变状态，或者进行随机时长等待
     *
     */
}
