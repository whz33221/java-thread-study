package com.study.第10章I活跃性问题;

public class Note {
    /**
     * 活跃性问题：死锁、饥饿、活锁
     * 一.死锁：线程间发生锁冲突，导致阻塞
     *  1.分类
     *        1）顺序死锁
     *          某个方法定义了错误的获取锁顺序，导致线程没有以统一的方法进行获取锁，发生死锁
     *        2）动态的顺序死锁
     *         方法没有明确定义获取锁顺序，根据传参数，会有不同的锁顺序，其中包括错误的获取锁顺序，导致死锁发生
     *       3）协作之间对象之间发生死锁
     *           对象协作时，原理与前者相同，当因为获取锁隐藏于被调用的方法内，非常难以分辨---应对：开放调用
     *        4）资源死锁
     *          基于资源的死锁：
     *             1>等待双方在用资源死锁，比如两个数据库，线程1获取了A库所有资源，线程2获取了B库所有资源，线程1此时需要获取B库资源才能往下执行，
     *            线程2同理，导致双方永远无法获取到资源，发生死锁
                   2>线程饥饿死锁：比如单线程池，提交了AB任务，A任务执行到中间，需要等B完成，此时B永远在等待队列，导致死锁
     *  2.应对措施
     *         1）规范的设计
     *           1>开发方调用：不要使用同步方法，改用同步代码块，显式的进行加锁
                 2>一旦涉及到多个锁，我们就必须定义获取锁的全局统一顺序
                 3>把获取锁所要遵循的协议，要写入正式的文档
     *       2）定时锁设计
     *             1>使用显式锁，可以设置获取锁的超时时间，超时，就执行相对应的应对策略即可
     *          3）通过线程转储信息类分析
     *              1>Idea中即可查看
     *            2>JDK的jstack也可以进行查看
     *  3.如何排查死锁
     *        1）通过线程转储信息来分析死锁
     *
     *
     * 二.饥饿：当线程由于无法访问它所需要的资源而不能继续执行时，就会发生饥饿
     *  1.发生原因
     *       1）java线程的优先级使用不当
     *       2）某个线程持有了锁后，执行了个无限循环的任务，导致其他线程无法获取到锁
     *  2.应对
     *        1）使用默认线程优先级
     *        ps：一旦修改了优先级，则程序就对平台具有依赖性，不同的平台，对优先级的处理也不同
     *        2）每个同步任务必须是可以运行结束的
     *        3）降低锁竞争
     *
     *
     * 三.活锁：线程间不停的互相礼让（不断重复相同的操作），导致线程没有阻塞，但任务进度始终无法往下执行
     *  1.发生原因
     *      两个线程在协作时，在一些判断对方状态的操作时，表现出相同状态，且修改自身状态步调
     *  相同，导致不断判断，不断修改
     *  2.应对
     *       加入随机元素，比如随机的改变状态，或者进行随机时长等待
     *
     */
}
