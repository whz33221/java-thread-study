package com.study.第10章I活跃性问题;

public class Note {
    /**
     * 活跃性问题：死锁、饥饿、活锁
     * 一.死锁：线程间发生锁冲突，导致阻塞
     * 1.分类
     *      1）顺序死锁
     *      2）动态的顺序死锁
     *      3）协作之间对象之间发生死锁
     *      4）资源死锁
     * 2.应对措施
     *      1）开放调用
     *      2）定时锁设计
     * 3.如何排查死锁
     *      1）通过线程转储信息来分析死锁
     *
     *
     * 二.饥饿：当线程由于无法访问它所需要的资源而不能继续执行时，就会发生饥饿
     * 1.发生原因
     *      1）java线程的优先级使用不当
     *      2）某个线程持有了锁后，执行了个无限循环的任务，导致其他线程无法获取到锁
     * 2.应对
     *      1）使用默认线程优先级
     *      ps：一旦修改了优先级，则程序就对平台具有依赖性，不同的平台，对优先级的处理也不同
     *      2）每个同步任务必须是可以运行结束的
     *
     *
     * 三.活锁：线程间不停的互相礼让（不断重复相同的操作），导致线程没有阻塞，但任务进度始终无法往下执行
     * 1.发生原因
     *      两个线程在协作时，在一些判断对方状态的操作时，表现出相同状态，且修改自身状态步调
     * 相同，导致不断判断，不断修改
     * 2.应对
     *      加入随机元素，比如随机的改变状态，或者进行随机时长等待
     *
     */
}
